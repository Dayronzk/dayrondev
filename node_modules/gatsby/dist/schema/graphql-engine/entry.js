"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = exports.GraphQLEngine = void 0;

require("../../utils/engines-fs-provider");

var _index = require("../index");

var _lmdbDatastore = require("../../datastore/lmdb/lmdb-datastore");

var _redux = require("../../redux");

var _actions = require("../../redux/actions");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _createGraphqlRunner = require("../../bootstrap/create-graphql-runner");

var _waitUntilJobsComplete = require("../../utils/wait-until-jobs-complete");

var _requireGatsbyPlugin = require("../../utils/require-gatsby-plugin");

var _apiRunnerNode = _interopRequireDefault(require("../../utils/api-runner-node"));

var _findPageByPath = require("../../utils/find-page-by-path");

var _datastore = require("../../datastore");

var _queryEnginePlugins = require(".cache/query-engine-plugins");

class GraphQLEngine {
  // private schema: GraphQLSchema
  constructor({
    dbPath
  }) {
    (0, _lmdbDatastore.setupLmdbStore)({
      dbPath
    }); // start initializing runner ASAP

    this.getRunner();
  }

  async _doGetRunner() {
    // @ts-ignore SCHEMA_SNAPSHOT is being "inlined" by bundler
    _redux.store.dispatch(_actions.actions.createTypes(SCHEMA_SNAPSHOT)); // TODO: FLATTENED_PLUGINS needs to be merged with plugin options from gatsby-config
    //  (as there might be non-serializable options, i.e. functions)


    _redux.store.dispatch({
      type: `SET_SITE_FLATTENED_PLUGINS`,
      payload: _queryEnginePlugins.flattenedPlugins
    });

    for (const pluginName of Object.keys(_queryEnginePlugins.gatsbyNodes)) {
      (0, _requireGatsbyPlugin.setGatsbyPluginCache)({
        name: pluginName,
        resolve: ``
      }, `gatsby-node`, _queryEnginePlugins.gatsbyNodes[pluginName]);
    }

    for (const pluginName of Object.keys(_queryEnginePlugins.gatsbyWorkers)) {
      (0, _requireGatsbyPlugin.setGatsbyPluginCache)({
        name: pluginName,
        resolve: ``
      }, `gatsby-worker`, _queryEnginePlugins.gatsbyWorkers[pluginName]);
    }

    if ("" === `4`) {
      await (0, _apiRunnerNode.default)(`onPluginInit`);
    } else {
      await (0, _apiRunnerNode.default)(`unstable_onPluginInit`);
    }

    await (0, _apiRunnerNode.default)(`createSchemaCustomization`); // Build runs
    // Note: skipping inference metadata because we rely on schema snapshot

    await (0, _index.build)({
      fullMetadataBuild: false,
      freeze: true
    });
    return (0, _createGraphqlRunner.createGraphQLRunner)(_redux.store, _reporter.default);
  }

  async getRunner() {
    if (!this.runnerPromise) {
      this.runnerPromise = this._doGetRunner();
    }

    return this.runnerPromise;
  }

  async runQuery(...args) {
    const graphqlRunner = await this.getRunner();
    const result = await graphqlRunner(...args); // Def not ideal - this is just waiting for all jobs and not jobs for current
    // query, but we don't track jobs per query right now
    // TODO: start tracking jobs per query to be able to await just those

    await (0, _waitUntilJobsComplete.waitUntilAllJobsComplete)();
    return result;
  }

  findPageByPath(pathName) {
    // adapter so `findPageByPath` use SitePage nodes in datastore
    // instead of `pages` redux slice
    const state = {
      pages: {
        get(pathName) {
          return (0, _datastore.getDataStore)().getNode(`SitePage ${pathName}`);
        },

        values() {
          return (0, _datastore.getDataStore)().iterateNodesByType(`SitePage`);
        }

      }
    };
    return (0, _findPageByPath.findPageByPath)(state, pathName, false);
  }

}

exports.GraphQLEngine = GraphQLEngine;
var _default = {
  GraphQLEngine
};
exports.default = _default;
//# sourceMappingURL=entry.js.map
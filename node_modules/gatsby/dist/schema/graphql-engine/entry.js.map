{"version":3,"sources":["../../../src/schema/graphql-engine/entry.ts"],"names":["GraphQLEngine","constructor","dbPath","getRunner","_doGetRunner","store","dispatch","actions","createTypes","SCHEMA_SNAPSHOT","type","payload","flattenedPlugins","pluginName","Object","keys","gatsbyNodes","name","resolve","gatsbyWorkers","fullMetadataBuild","freeze","reporter","runnerPromise","runQuery","args","graphqlRunner","result","findPageByPath","pathName","state","pages","get","getNode","values","iterateNodesByType"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAIA;;AAEA;;AACA;;AAEA;;AACA;;AACA;;AAOO,MAAMA,aAAN,CAAoB;AACzB;AAGAC,EAAAA,WAAW,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAiC;AAC1C,uCAAe;AAAEA,MAAAA;AAAF,KAAf,EAD0C,CAE1C;;AACA,SAAKC,SAAL;AACD;;AAEyB,QAAZC,YAAY,GAAoB;AAC5C;AACAC,iBAAMC,QAAN,CAAeC,iBAAQC,WAAR,CAAoBC,eAApB,CAAf,EAF4C,CAI5C;AACA;;;AACAJ,iBAAMC,QAAN,CAAe;AACbI,MAAAA,IAAI,EAAG,4BADM;AAEbC,MAAAA,OAAO,EAAEC;AAFI,KAAf;;AAKA,SAAK,MAAMC,UAAX,IAAyBC,MAAM,CAACC,IAAP,CAAYC,+BAAZ,CAAzB,EAAmD;AACjD,qDACE;AAAEC,QAAAA,IAAI,EAAEJ,UAAR;AAAoBK,QAAAA,OAAO,EAAG;AAA9B,OADF,EAEG,aAFH,EAGEF,gCAAYH,UAAZ,CAHF;AAKD;;AACD,SAAK,MAAMA,UAAX,IAAyBC,MAAM,CAACC,IAAP,CAAYI,iCAAZ,CAAzB,EAAqD;AACnD,qDACE;AAAEF,QAAAA,IAAI,EAAEJ,UAAR;AAAoBK,QAAAA,OAAO,EAAG;AAA9B,OADF,EAEG,eAFH,EAGEC,kCAAcN,UAAd,CAHF;AAKD;;AACD,QAAI,OAA2B,GAA/B,EAAmC;AACjC,YAAM,4BAAe,cAAf,CAAN;AACD,KAFD,MAEO;AACL,YAAM,4BAAe,uBAAf,CAAN;AACD;;AACD,UAAM,4BAAe,2BAAf,CAAN,CA9B4C,CAgC5C;AACA;;AACA,UAAM,kBAAM;AAAEO,MAAAA,iBAAiB,EAAE,KAArB;AAA4BC,MAAAA,MAAM,EAAE;AAApC,KAAN,CAAN;AAEA,WAAO,8CAAoBhB,YAApB,EAA2BiB,iBAA3B,CAAP;AACD;;AAEsB,QAATnB,SAAS,GAAoB;AACzC,QAAI,CAAC,KAAKoB,aAAV,EAAyB;AACvB,WAAKA,aAAL,GAAqB,KAAKnB,YAAL,EAArB;AACD;;AACD,WAAO,KAAKmB,aAAZ;AACD;;AAEoB,QAARC,QAAQ,CAAC,GAAGC,IAAJ,EAAkD;AACrE,UAAMC,aAAa,GAAG,MAAM,KAAKvB,SAAL,EAA5B;AACA,UAAMwB,MAAM,GAAG,MAAMD,aAAa,CAAC,GAAGD,IAAJ,CAAlC,CAFqE,CAGrE;AACA;AACA;;AACA,UAAM,sDAAN;AACA,WAAOE,MAAP;AACD;;AAEMC,EAAAA,cAAc,CAACC,QAAD,EAA4C;AAC/D;AACA;AACA,UAAMC,KAAK,GAAG;AACZC,MAAAA,KAAK,EAAE;AACLC,QAAAA,GAAG,CAACH,QAAD,EAA4C;AAC7C,iBAAO,+BAAeI,OAAf,CAAwB,YAAWJ,QAAS,EAA5C,CAAP;AAGD,SALI;;AAMLK,QAAAA,MAAM,GAA0B;AAC9B,iBAAO,+BAAeC,kBAAf,CACJ,UADI,CAAP;AAGD;;AAVI;AADK,KAAd;AAeA,WAAO,oCAAeL,KAAf,EAAsBD,QAAtB,EAAgC,KAAhC,CAAP;AACD;;AArFwB;;;eAwFZ;AAAE7B,EAAAA;AAAF,C","sourcesContent":["import \"../../utils/engines-fs-provider\"\nimport { build } from \"../index\"\nimport { setupLmdbStore } from \"../../datastore/lmdb/lmdb-datastore\"\nimport { store } from \"../../redux\"\nimport { actions } from \"../../redux/actions\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport {\n  createGraphQLRunner,\n  Runner,\n} from \"../../bootstrap/create-graphql-runner\"\nimport { waitUntilAllJobsComplete } from \"../../utils/wait-until-jobs-complete\"\n\nimport { setGatsbyPluginCache } from \"../../utils/require-gatsby-plugin\"\nimport apiRunnerNode from \"../../utils/api-runner-node\"\nimport type { IGatsbyPage, IGatsbyState } from \"../../redux/types\"\nimport { findPageByPath } from \"../../utils/find-page-by-path\"\nimport { getDataStore } from \"../../datastore\"\nimport {\n  gatsbyNodes,\n  gatsbyWorkers,\n  flattenedPlugins,\n  // @ts-ignore\n} from \".cache/query-engine-plugins\"\n\nexport class GraphQLEngine {\n  // private schema: GraphQLSchema\n  private runnerPromise?: Promise<Runner>\n\n  constructor({ dbPath }: { dbPath: string }) {\n    setupLmdbStore({ dbPath })\n    // start initializing runner ASAP\n    this.getRunner()\n  }\n\n  private async _doGetRunner(): Promise<Runner> {\n    // @ts-ignore SCHEMA_SNAPSHOT is being \"inlined\" by bundler\n    store.dispatch(actions.createTypes(SCHEMA_SNAPSHOT))\n\n    // TODO: FLATTENED_PLUGINS needs to be merged with plugin options from gatsby-config\n    //  (as there might be non-serializable options, i.e. functions)\n    store.dispatch({\n      type: `SET_SITE_FLATTENED_PLUGINS`,\n      payload: flattenedPlugins,\n    })\n\n    for (const pluginName of Object.keys(gatsbyNodes)) {\n      setGatsbyPluginCache(\n        { name: pluginName, resolve: `` },\n        `gatsby-node`,\n        gatsbyNodes[pluginName]\n      )\n    }\n    for (const pluginName of Object.keys(gatsbyWorkers)) {\n      setGatsbyPluginCache(\n        { name: pluginName, resolve: `` },\n        `gatsby-worker`,\n        gatsbyWorkers[pluginName]\n      )\n    }\n    if (_CFLAGS_.GATSBY_MAJOR === `4`) {\n      await apiRunnerNode(`onPluginInit`)\n    } else {\n      await apiRunnerNode(`unstable_onPluginInit`)\n    }\n    await apiRunnerNode(`createSchemaCustomization`)\n\n    // Build runs\n    // Note: skipping inference metadata because we rely on schema snapshot\n    await build({ fullMetadataBuild: false, freeze: true })\n\n    return createGraphQLRunner(store, reporter)\n  }\n\n  private async getRunner(): Promise<Runner> {\n    if (!this.runnerPromise) {\n      this.runnerPromise = this._doGetRunner()\n    }\n    return this.runnerPromise\n  }\n\n  public async runQuery(...args: Parameters<Runner>): ReturnType<Runner> {\n    const graphqlRunner = await this.getRunner()\n    const result = await graphqlRunner(...args)\n    // Def not ideal - this is just waiting for all jobs and not jobs for current\n    // query, but we don't track jobs per query right now\n    // TODO: start tracking jobs per query to be able to await just those\n    await waitUntilAllJobsComplete()\n    return result\n  }\n\n  public findPageByPath(pathName: string): IGatsbyPage | undefined {\n    // adapter so `findPageByPath` use SitePage nodes in datastore\n    // instead of `pages` redux slice\n    const state = {\n      pages: {\n        get(pathName: string): IGatsbyPage | undefined {\n          return getDataStore().getNode(`SitePage ${pathName}`) as\n            | IGatsbyPage\n            | undefined\n        },\n        values(): Iterable<IGatsbyPage> {\n          return getDataStore().iterateNodesByType(\n            `SitePage`\n          ) as Iterable<IGatsbyPage>\n        },\n      },\n    } as unknown as IGatsbyState\n\n    return findPageByPath(state, pathName, false)\n  }\n}\n\nexport default { GraphQLEngine }\n"],"file":"entry.js"}
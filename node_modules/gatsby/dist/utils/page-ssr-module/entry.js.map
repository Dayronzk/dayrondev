{"version":3,"sources":["../../../src/utils/page-ssr-module/entry.ts"],"names":["pageTemplateDetailsMap","INLINED_TEMPLATE_TO_DETAILS","getData","pathName","graphqlEngine","req","potentialPagePath","page","findPageByPath","Error","templateDetails","componentChunkName","executionPromises","results","serverData","query","push","runQuery","context","then","queryResults","mode","mod","__non_webpack_require__","serverDataResults","Promise","all","props","pageContext","serverDataHeaders","headers","renderPageData","data","path","matchPath","staticQueryHashes","JSON","stringify","parse","readStaticQueryContext","templatePath","filePath","join","__dirname","rawSQContext","fs","readFile","renderHTML","pageData","staticQueryContext","pagePath","assets","inlinePageData","html"],"mappings":"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","sourcesContent":["// just types - those should not be bundled\nimport type { GraphQLEngine } from \"../../schema/graphql-engine/entry\"\nimport type { IExecutionResult } from \"../../query/types\"\nimport type { IGatsbyPage } from \"../../redux/types\"\nimport type { IScriptsAndStyles } from \"../client-assets-for-template\"\nimport type { IPageDataWithQueryResult } from \"../page-data\"\nimport type { Request } from \"express\"\n\n// actual imports\nimport \"../engines-fs-provider\"\nimport * as path from \"path\"\nimport * as fs from \"fs-extra\"\nimport {\n  constructPageDataString,\n  getPagePathFromPageDataPath,\n} from \"../page-data-helpers\"\n// @ts-ignore render-page import will become valid later on (it's marked as external)\nimport htmlComponentRenderer from \"./render-page\"\nimport { getServerData, IServerData } from \"../get-server-data\"\n\nexport interface ITemplateDetails {\n  query: string\n  staticQueryHashes: Array<string>\n  assets: IScriptsAndStyles\n}\nexport interface ISSRData {\n  results: IExecutionResult\n  page: IGatsbyPage\n  templateDetails: ITemplateDetails\n  potentialPagePath: string\n  serverDataHeaders?: Record<string, string>\n}\n\nconst pageTemplateDetailsMap: Record<\n  string,\n  ITemplateDetails\n  // @ts-ignore INLINED_TEMPLATE_TO_DETAILS is being \"inlined\" by bundler\n> = INLINED_TEMPLATE_TO_DETAILS\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ndeclare const __non_webpack_require__: typeof require\n\nexport async function getData({\n  pathName,\n  graphqlEngine,\n  req,\n}: {\n  graphqlEngine: GraphQLEngine\n  pathName: string\n  req?: Partial<Pick<Request, \"query\" | \"method\" | \"url\" | \"headers\">>\n}): Promise<ISSRData> {\n  const potentialPagePath = getPagePathFromPageDataPath(pathName) || pathName\n\n  // 1. Find a page for pathname\n  const page = graphqlEngine.findPageByPath(potentialPagePath)\n\n  if (!page) {\n    // page not found, nothing to run query for\n    throw new Error(`Page for \"${pathName}\" not found`)\n  }\n\n  // 2. Lookup query used for a page (template)\n  const templateDetails = pageTemplateDetailsMap[page.componentChunkName]\n  if (!templateDetails) {\n    throw new Error(\n      `Page template details for \"${page.componentChunkName}\" not found`\n    )\n  }\n\n  const executionPromises: Array<Promise<any>> = []\n\n  // 3. Execute query\n  // query-runner handles case when query is not there - so maybe we should consider using that somehow\n  let results: IExecutionResult = {}\n  let serverData: IServerData | undefined\n  if (templateDetails.query) {\n    executionPromises.push(\n      graphqlEngine\n        .runQuery(templateDetails.query, {\n          ...page,\n          ...page.context,\n        })\n        .then(queryResults => {\n          results = queryResults\n        })\n    )\n  }\n\n  // 4. (if SSR) run getServerData\n  if (page.mode === `SSR`) {\n    const mod = __non_webpack_require__(`./routes/${page.componentChunkName}`)\n    executionPromises.push(\n      getServerData(req, page, potentialPagePath, mod).then(\n        serverDataResults => {\n          serverData = serverDataResults\n        }\n      )\n    )\n  }\n\n  await Promise.all(executionPromises)\n\n  if (serverData) {\n    results.serverData = serverData.props\n  }\n  results.pageContext = page.context\n\n  return {\n    results,\n    page,\n    templateDetails,\n    potentialPagePath,\n    serverDataHeaders: serverData?.headers,\n  }\n}\n\nexport async function renderPageData({\n  data,\n}: {\n  data: ISSRData\n}): Promise<IPageDataWithQueryResult> {\n  const results = await constructPageDataString(\n    {\n      componentChunkName: data.page.componentChunkName,\n      path:\n        data.page.mode !== `SSG` && data.page.matchPath\n          ? data.potentialPagePath\n          : data.page.path,\n      matchPath: data.page.matchPath,\n      staticQueryHashes: data.templateDetails.staticQueryHashes,\n    },\n    JSON.stringify(data.results)\n  )\n\n  return JSON.parse(results)\n}\n\nconst readStaticQueryContext = async (\n  templatePath: string\n): Promise<Record<string, { data: unknown }>> => {\n  const filePath = path.join(\n    __dirname,\n    `sq-context`,\n    templatePath,\n    `sq-context.json`\n  )\n  const rawSQContext = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawSQContext)\n}\n\nexport async function renderHTML({\n  data,\n  pageData,\n}: {\n  data: ISSRData\n  pageData?: IPageDataWithQueryResult\n}): Promise<string> {\n  if (!pageData) {\n    pageData = await renderPageData({ data })\n  }\n\n  const staticQueryContext = await readStaticQueryContext(\n    data.page.componentChunkName\n  )\n\n  const results = await htmlComponentRenderer({\n    pagePath:\n      data.page.mode !== `SSG` && data.page.matchPath\n        ? data.potentialPagePath\n        : data.page.path,\n    pageData,\n    staticQueryContext,\n    ...data.templateDetails.assets,\n    inlinePageData: data.page.mode === `SSR` && data.results.serverData,\n  })\n\n  return results.html\n}\n"],"file":"entry.js"}
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getData = getData;
exports.renderPageData = renderPageData;
exports.renderHTML = renderHTML;

require("../engines-fs-provider");

var path = _interopRequireWildcard(require("path"));

var fs = _interopRequireWildcard(require("fs-extra"));

var _pageDataHelpers = require("../page-data-helpers");

var _renderPage = _interopRequireDefault(require("./render-page"));

var _getServerData = require("../get-server-data");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// just types - those should not be bundled
// actual imports
// @ts-ignore render-page import will become valid later on (it's marked as external)
const pageTemplateDetailsMap = INLINED_TEMPLATE_TO_DETAILS; // eslint-disable-next-line @typescript-eslint/naming-convention

async function getData({
  pathName,
  graphqlEngine,
  req
}) {
  var _serverData;

  const potentialPagePath = (0, _pageDataHelpers.getPagePathFromPageDataPath)(pathName) || pathName; // 1. Find a page for pathname

  const page = graphqlEngine.findPageByPath(potentialPagePath);

  if (!page) {
    // page not found, nothing to run query for
    throw new Error(`Page for "${pathName}" not found`);
  } // 2. Lookup query used for a page (template)


  const templateDetails = pageTemplateDetailsMap[page.componentChunkName];

  if (!templateDetails) {
    throw new Error(`Page template details for "${page.componentChunkName}" not found`);
  }

  const executionPromises = []; // 3. Execute query
  // query-runner handles case when query is not there - so maybe we should consider using that somehow

  let results = {};
  let serverData;

  if (templateDetails.query) {
    executionPromises.push(graphqlEngine.runQuery(templateDetails.query, { ...page,
      ...page.context
    }).then(queryResults => {
      results = queryResults;
    }));
  } // 4. (if SSR) run getServerData


  if (page.mode === `SSR`) {
    const mod = __non_webpack_require__(`./routes/${page.componentChunkName}`);

    executionPromises.push((0, _getServerData.getServerData)(req, page, potentialPagePath, mod).then(serverDataResults => {
      serverData = serverDataResults;
    }));
  }

  await Promise.all(executionPromises);

  if (serverData) {
    results.serverData = serverData.props;
  }

  results.pageContext = page.context;
  return {
    results,
    page,
    templateDetails,
    potentialPagePath,
    serverDataHeaders: (_serverData = serverData) === null || _serverData === void 0 ? void 0 : _serverData.headers
  };
}

async function renderPageData({
  data
}) {
  const results = await (0, _pageDataHelpers.constructPageDataString)({
    componentChunkName: data.page.componentChunkName,
    path: data.page.mode !== `SSG` && data.page.matchPath ? data.potentialPagePath : data.page.path,
    matchPath: data.page.matchPath,
    staticQueryHashes: data.templateDetails.staticQueryHashes
  }, JSON.stringify(data.results));
  return JSON.parse(results);
}

const readStaticQueryContext = async templatePath => {
  const filePath = path.join(__dirname, `sq-context`, templatePath, `sq-context.json`);
  const rawSQContext = await fs.readFile(filePath, `utf-8`);
  return JSON.parse(rawSQContext);
};

async function renderHTML({
  data,
  pageData
}) {
  if (!pageData) {
    pageData = await renderPageData({
      data
    });
  }

  const staticQueryContext = await readStaticQueryContext(data.page.componentChunkName);
  const results = await (0, _renderPage.default)({
    pagePath: data.page.mode !== `SSG` && data.page.matchPath ? data.potentialPagePath : data.page.path,
    pageData,
    staticQueryContext,
    ...data.templateDetails.assets,
    inlinePageData: data.page.mode === `SSR` && data.results.serverData
  });
  return results.html;
}
//# sourceMappingURL=entry.js.map